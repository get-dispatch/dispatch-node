

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> dispatch.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Namespaces</h3><ul><li><a href="Dispatch.deliveries.html">deliveries</a></li></ul><h3>Classes</h3><ul><li><a href="Dispatch.html">Dispatch</a></li></ul><h3><a href="global.html">Global</a></h3></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>dispatch.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const {
  _retrieveDelivery,
  _listDeliveries,
  _createDelivery,
  _purchaseDelivery,
  _refundDelivery,
} = require("./modules/deliveries");

const { _retrieveLocation } = require("./modules/locations");

const _createNetworkConfig = require("./util/network-config");

/**
 * Creates a new Dispatch class. Once this class is initialized, you can use any of the namespaces with a method to use tge API.
 * @name Dispatch
 * @class
 * @classdesc This is the main class that will be the entry point into dispatch. You can initialize this class with your API Key.
 * @param {string} token - initialize the class with your API key.
 * @param {string} [env="production"] - Unless you have development keys, just leave this to the default value.
 *
 * @example const dispatch = new Dispatch(&lt;YOUR_API_KEY>)
 *
 */
module.exports = class Dispatch {
  constructor(apikey, env = "production", debug = false) {
    this.apikey = apikey;
    this.env = env;
    this.debug = debug;

    /**
     *
     * @memberof Dispatch
     * @namespace deliveries
     */
    this.deliveries = {
      /**
       * Retrieves a delivery using it's ID
       * @memberof Dispatch.deliveries
       * @namespace Dispatch.deliveries.retrieve
       *
       * @method retrieve
       * @param {string} id - The ID of the delivery that you want to retrieve
       * @returns {Promise&lt;Response>} Returns the response object. The Response's [data property]{@link Delivery} will be an array of {@link Delivery} objects.
       *
       * @example const response = await dispatch.deliveries.retrieve("del_fjdsklfju8jisjfdisoiu89j")
       * const delivery = response.data //this will contain the delivery object
       */
      retrieve: function (id) {
        return new Promise((resolve, reject) => {
          const _config = _createNetworkConfig(apikey, env);
          _retrieveDelivery(id, _config)
            .then((data) => {
              resolve(data);
            })
            .catch((err) => {
              console.error(err);
              reject(err);
            });
        });
      },

      /**
       * Get a paginated list of deliveries
       * @memberof Dispatch.deliveries
       * @namespace Dispatch.deliveries.list
       *
       * @method list
       * @param {Object} options - The options that you can use to return results
       * @param {integer} options.limit - The amount of deliveries you want returned. The default is 15, but ranges from 1 to 100
       * @param {integer} options.page - The page you want to deliveries to start at. For example, a limit of 15 with a page value of 3, would return deliveries 30 - 45. The response object for the .list() method will have a pagination property which you can use to determine if there are more values in the database.
       * @returns {Promise&lt;Response>} Returns the response object. The Response's [data property]{@link Delivery} will be an array of {@link Delivery} objects.
       *
       * @example const response = await dispatch.deliveries.list()
       * const deliveries = response.data //this will have an array of delivery objects
       *
       * //check if there are more values in the database
       * if (data.pagination.has_more) {
       *    //the delivery objects have a lot of data and setting the pagination to a loop can really hurt performance
       *    //It's advised to just query in batches
       *    //To query for the next page (batch) of deliveries you could do something like:
       *
       *    const nextResponse = dispatch.deliveries.list({limit: response.pagination.limit, page: response.pagination.current_page + 1})
       * }
       *
       */
      list: function (options) {
        return new Promise((resolve, reject) => {
          const _config = _createNetworkConfig(apikey, env);
          _listDeliveries(options, _config)
            .then((data) => {
              resolve(data);
            })
            .catch((err) => {
              console.error(err);
              reject(err);
            });
        });
      },

      /**
       * Create a delivery intent. This will give you a list of rates to choose from.
       * @memberof Dispatch.deliveries
       * @namespace Dispatch.deliveries.create
       *
       * @method create
       * @param {Object} sender - the details about there this package is coming from
       * @param {string} sender.name - The name of the sender. This could be a company name or a person's name
       * @param {string} sender.email - The email of the sender. For on demand deliveries, this email will be used by the courier to contact the sender in case of any issues
       * @param {string} [sender.phone] - The phone number of this sender that an on demand courier could use to contact this sender if there is an issue
       * @param {string} [sender.location_id] - If you already have a location object, you can simply pass the id of the location and we'll use it's address.
       * @param {(string|Object&lt;NewAddress>)} [sender.address] - If you do not have a location_id, you can just send your address and we'll create a location object for you. Your address can just be a full string and we'll parse it on our end, or you can send it as an object
       * @param {Object} recipient - the details about there this package is coming from
       * @param {string} recipient.name - The name of the sender. This could be a company name or a person's name
       * @param {string} recipient.email - The email of the sender. For on demand deliveries, this email will be used by the courier to contact the sender in case of any issues
       * @param {string} [recipient.phone] - The phone number of this recipient that an on demand courier could use to contact this recipient if there is an issue
       * @param {(string|Object&lt;NewAddress>)} recipient.address - Your address can just be a full string and we'll parse it on our end, or you can send it as an object
       * @param {Array&lt;Parcel>} parcels - An array of parcels that you want to send
       * @param {Object} [options] - Additional options to include in your delivery.
       * @param {Array} [options.rate_cards] - An array of rate cards that you want to use for this transaction. These will be used instead of the rate cards you set on your Dispatch Dashboard
       * @returns {Promise&lt;Response>} Returns the response object. The Response's [data property]{@link Delivery} will be an array of {@link Delivery} objects.
       *
       * @example
       * const sender = {
       *    name: "Dispatch Roasters"
       *    email: roasters@getdispatch.app,
       *    location_id: "loc_j83498fhweofh4937fh"
       * }
       *
       * const recipient = {
       *    name: "Jamie Jones"
       *    email: jamie.jones@getdispatch.app,
       *    address: {
       *        address_line1: "500 7th Ave",
       *        city: "New York",
       *        state: "NY"
       *        zipcode: "10018"
       *    }
       * }
       *
       * const parcel = {
       *    length: 10 // inches
       *    width: 10 // inches
       *    height: 10 // inches
       *    weight: 10 // pounds
       * }
       *
       * const response = await dispatch.deliveries.create(sender, recipient, [parcel])
       * const delivery = response.data //this will have the delivery object
       *
       */
      create: function (sender, recipient, parcels, options) {
        return new Promise((resolve, reject) => {
          const _config = _createNetworkConfig(apikey, env);
          _createDelivery(sender, recipient, parcels, options, _config)
            .then((data) => {
              resolve(data);
            })
            .catch((err) => {
              console.error(err);
              reject(err);
            });
        });
      },

      /**
       * Purchased a shipping label
       * @memberof Dispatch.deliveries
       * @namespace Dispatch.deliveries.buy
       *
       * @method buy
       * @param {string} delivery_id - The ID of the delivery for which you want to purchase a rate
       * @param {string} rate_id - The ID of the rate tha you wish to purchase
       * @param {Object} [options] - Additional options you want to add while purchasing this rate
       * @param {string} [options.payment_method] - The ID of the payment method you wish to use. We'll use the default card you have on file otherwise.
       * @returns {Promise&lt;Response>} Returns the response object. The Response's [data property]{@link Delivery} will be an array of {@link Delivery} objects.
       *
       * @example
       *
       * //assuming we already created the delivery, we have access to the rates array, if any were returned
       * //we can pass back the id of the rate that we want to purchase the delivery
       *
       * const delivery = response.data
       * const rate = delivery.rates[0].id //selected the first rate
       * const response = await dispatch.deliveries.buy(delivery.id, rate.id)
       *
       * //if the purchase was successful, the purchased rate will be available on the purchased_rate property
       * const purchasedRate = response.data.purchased_rate
       */
      buy: function (delivery_id, rate_id, options = {}) {
        return new Promise((resolve, reject) => {
          const _config = _createNetworkConfig(apikey, env);
          _purchaseDelivery(delivery_id, rate_id, options, _config)
            .then((data) => {
              resolve(data);
            })
            .catch((err) => {
              console.error(err);
              reject(err);
            });
        });
      },

      /**
       * Refund a shipping label that you have already purchased
       * @memberof Dispatch.deliveries
       * @namespace Dispatch.deliveries.refund
       *
       * @method refund
       * @param {string} delivery_id - The ID of the delivery that you want to refund.
       * @returns {Promise&lt;Response>} Returns the response object.
       *
       * @example
       *
       * //a refund can only be done on a purchased label that has not been used
       * //refunds for on demand couriers need to happen within 5 minutes
       *
       * const response = dispatch.deliveries.refund("del_28374n8iudshf3nqifub")
       */

      refund: function (delivery_id) {
        return new Promise((resolve, reject) => {
          const _config = _createNetworkConfig(apikey, env);
          _refundDelivery(delivery_id, _config)
            .then((data) => {
              resolve(data);
            })
            .catch((err) => {
              console.error(err);
              reject(err);
            });
        });
      },
    };

    // /**
    //  *
    //  * @memberof Dispatch
    //  * @namespace locations
    //  */
    // this.locations = {
    //   /**
    //    * Retrieves a location using its ID
    //    * @memberof Dispatch.locations
    //    * @namespace Dispatch.locations.retrieve
    //    *
    //    * @method retrieve
    //    * @param {string} id - The ID of the location that you want to retrieve
    //    * @returns {Promise&lt;Response>} Returns the response object. The Response's [data property]{@link Location} will be an array of {@link Location} objects.
    //    *
    //    * @example const response = await dispatch.locations.retrieve("loc_fjdsklfju8jisjfdisoiu89j")
    //    * const delivery = response.data //this will contain the location object
    //    */
    //   retrieve: function (id) {
    //     return new Promise((resolve, reject) => {
    //       const _config = _createNetworkConfig(apikey, env);
    //       _retrieveLocation(id, _config)
    //         .then((data) => {
    //           resolve(data);
    //         })
    //         .catch((err) => {
    //           console.error(err);
    //           reject(err);
    //         });
    //     });
    //   },
    // };
  }
};

/* -------------------------------------------------------------------------- */
/*                                  TYPE DEFS                                 */
/* -------------------------------------------------------------------------- */

/**
 * The Delivery object. Any of the properties could have null values if the delivery is not purchased.
 * @typedef {Object} Delivery
 * @property {string} id - The delivery ID
 * @property {integer} amount - The amount that was payed for the delivery as an integer.
 * @property {Object} branding - Specified the branding for this delivery
 * @property {integer} branding.email - If an email will be sent by Dispatch, this determines which logo will be on the email
 * @property {integer} branding.label - Which logo should be placed on the label
 * @property {Object} courier - The courier object if the delivery is on demand. This will be deprecated in the future as the same data is found in the Provider object that is attached to the Rate.
 * @property {integer} created_at - epoch time in seconds
 * @todo {Object} customs_declaration - Any customs declarations for international shipping
 * @property {string} estimated_delivery - A human readable string value for the estimated delivery date and time.
 * @property {Object} grace_period -The grace period that an on_demand courier will wait for and the fees for going over it.
 * @property {integer} grace_period.fee - The grace period fee as an integer.
 * @property {integer} grace_period.minutes - The amount of minutes that the grace period is good for.
 * @todo {Object} insurance - The object representing the insurance
 * @property {string} intent_status - The status of the delivery intent. An intent can be "created" when rates were generated but not purchased yet, "expired" if the intent was not captured within 15 mins, "captured" which means that the intent was paid for, and "deleted" which is when the intent was removed from the database.
 * @property {string} label_name - The name of the shipping label as saved in the storage bucket. @deprecated This property will be removed.
 * @property {integer} lead_time_hours - The amount of lead time that was required for this delivery before an on_demand courier can pick it up.
 * @property {Array} live_location - The lat and lon coordinates of the the current location of the delivery. Not every courier supports this.
 * @property {Boolean} on_demand - If this delivery is for an on_demand courier
 * @property {Boolean} paid - If this delivery was paid for.
 * @property {Array&lt;Parcel>} parcels - An array of parcel objects, which are the boxes and items that were being transported.
 * @property {integer} pickup_wait_seconds - The amount of seconds that an on demand courier needed to wait after they arrived to pickup the package until it was marked as picked up.
 * @property {Object&lt;Rate>} purchased_rate - The rate that was purchased by the customer
 * @property {string} qr_code_url - If the label has a QR Code, this will be the url that is encoded on it.
 * @property {Array&lt;Rate>} rates - an array of rates that are returned when the delivery intent was created.
 * @property {Object&lt;Entity>} recipient - The recipient object. This is the person who is getting the package.
 * @property {string} refund_status - The refund status if one was requested. Funds will be credited back to the account after the refund status is approved by the carrier. Dispatch couriers refunds are immediate.
 * @property {Object&lt;Entity>} sender - The object representing the sender, which is the entity that initially sent that package.
 * @property {integer} shipment_date - The time in seconds from Epoch in seconds of the shipment date.
 * @property {string} status - The tracking status for the delivery. For a complete list see the github readme.
 * @property {string} substatus - The tracking substatus for the delivery. This gives much more detail about the package whereabouts. For a complete list see the github readme.
 * @property {boolean} test - If this was a test delivery
 * @property {boolean} tracking_notifications - Indicates if dispatch will send update emails for the delivery. This value is set on your dashboard {@link https://app.getdispatch.app/settings/company/branding}
 * @property {string} tracking_number - The tracking number for the delivery
 * @property {Object&lt;Tracker>} tracking_status - The current tracking status for this delivery
 * @property {Array&lt;Tracker>} tracking_updates - An array of all of the tracking updates for this delivery including the current one.
 * @property {string} type - The type of delivery this is: "traditional" or "marketplace"
 * @property {integer} updated_at - epoch time in seconds
 * @property {integer} value - The declared value of this delivery
 */

/**
 * The Entity object, which describes a company or person
 * @typedef {Object} Entity
 * @property {string} id - The entity ID
 * @property {Object} address - The address details of this entity
 * @property {string} address.address_line1
 * @property {string} address.address_line2
 * @property {string} address.city
 * @property {string} address.formatted_address - the combined address string including city, state, and zipcode
 * @property {string} address.place_name - in most cases this is the same as the city. For U.S. shipment, just ignore this
 * @property {string} address.state - the full string of the the state such as "California or New York"
 * @property {string} address.state_abbreviation - the abbreviation of the the state such as "CA or "NY"
 * @property {string} address.state_name - @deprecated this is now just called state
 * @property {string} address.street_name - the name of the street from address_line1
 * @property {string} address.street_number - the number of the street from address_line1.
 * @property {string} address.street_suffix - will we the last part of the street name like "St" or "Ln"
 * @property {string} address.textarea - if you will pre-fill an html textarea with the string, this includes the return values for the address to format into multiple lines
 * @property {string} address.timezone - the tz format for this addresses timezone. {@link https://en.wikipedia.org/wiki/Tz_database}
 * @property {boolean} address.verified - if this address was verified with USPS
 * @property {string} address.zipcode - the address zipcode. This is the same value as postal_code
 * @property {string} address.zipcode - the address zipcode. This is the same value as postal_code
 * @property {string} email - the email address to contact this entity
 * @property {string} name - the name of this entity
 * @property {(string|null)} phone - the phone number to contact this entity
 * @property {(string|null)} logo_url - The source for the logo. The image is a 256 x 256 square png.
 * @property {(string|null)} logo_url_trimmed - This logo is trimmed by us to remove the white space. Best used in emails. One of the sides is 256px, depending on the logo's shape.
 */

/**
 * The Rate object
 * @typedef {Object} Rate
 * @property {integer} amount - The price of this rate as an integer
 * @property {(string|null)} carrier_account - The carrier account / custom rate card that was used to price this rate
 * @property {integer} created_at - epoch time in seconds
 * @property {string} currency - the currency of this rate card as lowercase ISO 4217 format {@link https://en.wikipedia.org/wiki/ISO_4217}
 * @property {boolean} dispatch - if this rate was originated by dispatch APIs
 * @property {Object} service_level - describes how long the delivery will take
 * @property {(string)} service_level.id - The ID of the service level. Something like "dispatch_same_day"
 * @property {(string)} service_level.name - The human readable name of the service level. Something like "Same Day" or "USPS Overnight".
 * @property {string} service_level.arrives_by - the human readable string for the delivery date and time. For example: "Today by 9pm"
 * @property {integer} service_level.days - the amount of days that this delivery is estimated to take
 * @property {(integer|null)} service_level.pickup_at - epoch time in seconds when this order will be picked up
 * @property {(string|null)} service_level.terms - The terms for the service level
 * @property {Object} grace_period -The grace period that an on_demand courier will wait for and the fees for going over it.
 * @property {integer} grace_period.fee - The grace period fee as an integer.
 * @property {integer} grace_period.minutes - The amount of minutes that the grace period is good for.
 * @property {string} id - the id of this rate. This id will be passed to dispatch to purchase the rate
 * @property {(Object|null)} invoice - If the rate is generated by an on demand courier from dispatch, this will be a breakdown of the total cost.  Otherwise will be null
 * @property {integer} invoice.additional_items_fee - The cost for additional items if the order contained multiple packages and the courier changes this fee
 * @property {integer} invoice.dropoff_fee - The fixed dropoff fee that this courier charges
 * @property {integer} invoice.dropoff_rate - The rate this courier charges for the distance from pickup location to dropoff location
 * @property {integer} invoice.local_fee - If there are any local fees that are charged in the pickup or dropoff city
 * @property {integer} invoice.pickup_fee - The fixed pickup fee that this courier charges
 * @property {integer} invoice.pickup_rate - The rate this courier charges for the distance from to get to the pickup location
 * @property {(string|null)} invoice.rate_card - The id of the rate card that was used for this invoice
 * @property {integer} invoice.subtotal - The total before taxes
 * @property {integer} invoice.tax - The tax charged for this delivery
 * @property {integer} invoice.toll - Any tolls that were charged for this delivery
 * @property {integer} invoice.total - The final total for this invoice. This number is the same as the "amount"
 * @property {integer} lead_time_hours - The amount of hours that are needed in advance before the courier can get the the pickup destination
 * @property {boolean} on_demand - If this rate is an on demand courier
 * @property {integer} pickup_at - @deprecated epoch time in seconds when this order will be picked up. Same as service_level.pickup_at
 * @property {Object} provider - The provider is the courier or carrier that will be conducting the delivery
 * @property {string} provider.id - The ID of this provider
 * @property {string} provider.logo_url - The logo that of this provider
 * @property {string} provider.name - The name of this provider
 * @property {string} provider.support_email - The email that can be used to contact this provider
 * @property {(string|null)} provider.support_phone - The support phone number that can be used to contact this provider
 * @property {(string|null)} provider.support_url - The url that this provider has for support.
 * @property {boolean} test - If this was a test delivery or not
 */

/**
 * The Response Object. Every dispatch response will always have the same object that is returned
 * @typedef {Object} Response
 * @property {string} message - The message that could be displayed to an end user if the response is successful or ends in an error
 * @property {(Object|Array)} data - The data that was requested if any. If requesting lots of data like deliveries, the data will be formatted an an Array. If you're just pulling one item by an ID like a specific delivery, the response will be an Object.
 * @property {integer} status - The html status code for the response
 * @property {Array} errors - If there were errors, the array will be filled with the property names that caused the error.
 * @property {(string|null)} error_code - The server error code
 * @property {(Object|null)} pagination - when pulling multiple object like many deliveries, the pagination will let you know if there are more items that can be pulled from the database.
 * @property {integer} pagination.limit - the limit that was applied to the pagination. The default is 15 and the max is 100
 * @property {integer} pagination.current_page - The current page this pagination is on. If the limit is 15 and the current_page is 3, you know you're looking at items 30 - 45
 * @property {integer} pagination.has_more - Lets you know when you can paginate further
 * @property {integer} pagination.count - The amount of items that were returned.
 */

/**
 * The New Address Object. When creating a new address, you can either send the address a a string value or an object. If you're choosing an object, below are the properties you need to provide.
 * @typedef {Object} NewAddress
 * @param {string} NewAddress.address_line1 - The street address for this delivery
 * @param {string} [NewAddress.address_line2] - The second line of the street address if needed
 * @param {string} NewAddress.city - The name of the city
 * @param {string} NewAddress.state - The state. This can be the full state name like California or an abbreviation like NY
 * @param {string} NewAddress.zipcode - The zipcode. Technically this is optional but highly recommended you add this because it makes the address parser much more accurate.
 */

/**
 * The Parcel Object. When you create a parcel or retrieve a delivery, you'll always be referencing an array of parcels
 * @typedef {Object} Parcel
 * @property {integer} length - The length of the parcel in inches
 * @property {integer} width - The width of the parcel in inches
 * @property {integer} height - The height of the parcel in inches
 * @property {integer} weight - The weight of the parcel in pounds
 * @property {string} special_handling - Any special handling instructions that will be placed on the label. Limited to 12 characters. If you add more than 12 characters, we'll just use the first 12 instead of returning an error. The reason for the limit is that this is the most amount of characters that we can fit within the bounds of the current label.
 * @property {Array&lt;Item>} [items] - you can optionally include items that are in the box. This can be used for one click returns and custom disposition codes in the future.
 */

/**
 * The Item Object. This is optional but allows you to specify what the items are that are packaged in your box. In the future, this will be used to help facilitate one-click returns.
 * @typedef {Object} Item
 * @property {string} [name] - The name of this item
 * @property {string} [sku] - The item sku
 * @property {integer} [price] - The item's price as an integer
 * @property {integer} [value] - The item's declared values as an integer
 * @property {string} [product_id] - The id used to identify this product on your inventory system
 * @property {string} [variant_id] - If this is a specific variant of a product id
 * @property {integer} [length] - The length of the item in inches. Can use this for cheaper return labels if we know the box can be smaller.
 * @property {integer} [width] - The width of the item in inches. Can use this for cheaper return labels if we know the box can be smaller.
 * @property {integer} [height] - The height of the item in inches. Can use this for cheaper return labels if we know the box can be smaller.
 * @property {integer} [weight] - The weight of the item in pounds. Can use this for cheaper return labels if we know the box can be lighter.
 */

/**
 * The Tracker Object. This describes a tracking update.
 * @typedef {Object} Tracker
 * @property {Object} address - This is a basic address field that gives the general location of the item
 * @property {(String|null)} address.address_line1 - The street address. Many carriers do not support this field and it can often be null
 * @property {String} address.city - Name of the city
 * @property {String} address.state - Name of the state, not abbreviated
 * @property {String} address.zipcode - The zipcode
 * @property {(String|null)} comment - If the courier added a comment for this update it will be here. These comments are not filtered by Dispatch at the moment, so it's safer to use the `message` property for customer notifications.
 * @property {String} message - The human readable message about this status given by Dispatch
 * @property {String} status - The status string
 * @property {String} substatus - The sub_status string
 * @property {Array&lt;(String)>} images - An array that includes any images that were added to this tracker. If there are no images, the array will be empty.
 */
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">

                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
